esphome:
  name: esp32-mini-sdcard-spi
  friendly_name: esp32_mini_sdcard_spi


esp32:
  board: esp32dev
  framework:
    type: esp-idf


external_components:
  - source: github://shaikat21/esp32_sdspi
    components: [ sd_spi_card ]

logger:

wifi:
  ssid: "YOUR_SSID"
  password: "YOUR_PASS"

# If needed, enable IDF-style framework or ensure you're not forcing arduino
# esphome:
#   platformio_options:
#     framework: idf


# You can then use lambdas etc to call list_root, etc
# Example using on_boot
time:
  - platform: sntp
    id: my_time

sd_spi_card:
  id: sd_1
  spi_freq: 15000  # Khz, adjust according to your setup. For poor sd card/wiring keep it low(eg: 1000, ~1Khz)
  cs_pin: GPIO5
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO19
  update_interval: 10min # For Sensor


sensor:
  # Total space on card
  - platform: sd_spi_card
    type: total_space
    name: "SD Total Space"

  # Used space
  - platform: sd_spi_card
    type: used_space
    name: "SD Used Space"

  # Free space
  - platform: sd_spi_card
    type: free_space
    name: "SD Free Space"

  - platform: sd_spi_card
    type: file_size
    name: "text.txt size"
    path: "/timelog.txt"

  - platform: sd_spi_card
    type: file_size
    name: "Timelog csv size"
    path: "/timelog.csv"

  - platform: uptime
    type: seconds
    id: uptime_1

  - platform: wifi_signal
    id: wifi_sig

binary_sensor:
  - platform: sd_spi_card
    name: "SD Card Status"
    id: sd_status
    on_press:
      - logger.log: "SD card is mounted"
      - output.turn_off: led
    on_release:
      - logger.log: "SD card is not mounted"
      - output.turn_on: led

output:
  - platform: gpio
    id: led
    pin: 
      inverted: True
      number: 2

  - interval: 20min
    then:  # Delete row 110 - 150
      - lambda: |-
          if(id(sd_status).state) {
            id(sd_1).csv_delete_rows("/timelog.csv", -1, -1);
          }

  - interval: 30min
    then:  # keep last 100 row
      - lambda: |-
          if(id(sd_status).state) {
             id(sd_1).csv_keep_last_n("/timelog.csv", 10000);
          }

      
  - interval: 5s
    then:  # Retry to remount the SD card , if it is removed
      - lambda: |- 
          if (!id(sd_status).state) {
            ESP_LOGI("sd_spi_card", "Card not mounted â†’ trying remount...");
            id(sd_1).try_remount();
          }

  - interval: 3s
    then:  # Check SD card status 
      - lambda: |-
          if (id(sd_status).state) {
            id(sd_1).check_kappa();
          }
  - interval: 13s
    then:  # Replace a cell
      - lambda: |-
          id(sd_1).csv_replace_col("/timelog.csv", 427, 2, "test");

  - interval: 17s
    then:  # Read last_n_row  with or without condition (for col col_cond_index )
      - output.set_level:
          id: my_slow_pwm
          level: "50%"
      - delay: 2s   
      - lambda: |-
           if (id(sd_status).state) {
             const char *path = "/timelog.csv";
             int total = id(sd_1).csv_row_count(path);
             int last_n_row = 200;
             const char *condition = "1 - 70"; 
             int col_cond_index = 1;
           
             int row_start = total > last_n_row ? total - last_n_row : 0;
             int row_end   = total - 1;
           
             // Returns rows; each row's LAST element is a tag like "@row=193"
             // auto vals = id(sd_1).csv_read_rows_range(path, row_start, row_end); // without condition

             auto vals = id(sd_1).csv_read_rows_range(path, row_start, row_end, col_cond_index, condition);  // with condition

             for (auto &r : vals) {
               // Extract absolute row index from the tag
               int real_row = -1;
               if (!r.empty()) {
                 const std::string &tag = r.back();
                 if (tag.rfind("@row=", 0) == 0) {               // starts with "@row="
                   real_row = atoi(tag.c_str() + 5);             // skip "@row="
                 }
               }
           
               // Rebuild CSV line excluding the tag (if present)
               std::string line;
               size_t upto = r.size();
               if (upto > 0 && r.back().rfind("@row=", 0) == 0)  // don't include tag in the printed CSV
                 upto -= 1;
            
               for (size_t i = 0; i < upto; i++) {
                 line += r[i];
                 if (i + 1 < upto) line += ",";
               }
           
               ESP_LOGI("csv", "Row %d => %s", real_row, line.c_str());
             }
           }
      - delay: 1s
          
      - lambda: |-
          // force publish current SD card status
          if(id(sd_status).state){
            id(my_slow_pwm).set_level(0.0f);
          }
          else {id(my_slow_pwm).set_level(1.0f);}

