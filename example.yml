esphome:
  name: esp32-mini-sdcard-spi
  friendly_name: esp32_mini_sdcard_spi


esp32:
  board: esp32dev
  framework:
    type: esp-idf


external_components:
  - source: github://shaikat21/esp32_sdspi
    components: [ sd_spi_card ]

logger:

wifi:
  ssid: "YOUR_SSID"
  password: "YOUR_PASS"

# If needed, enable IDF-style framework or ensure you're not forcing arduino
# esphome:
#   platformio_options:
#     framework: idf


# You can then use lambdas etc to call list_root, etc
# Example using on_boot
time:
  - platform: sntp
    id: my_time

sd_spi_card:
  id: sd_1
  spi_freq: 15000  # Khz, adjust according to your setup. For poor sd card/wiring keep it low(eg: 1000, ~1Khz)
  cs_pin: GPIO5
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO19


sensor:
  # Total space on card
  - platform: sd_spi_card
    type: total_space
    name: "SD Total Space"

  # Used space
  - platform: sd_spi_card
    type: used_space
    name: "SD Used Space"

  # Free space
  - platform: sd_spi_card
    type: free_space
    name: "SD Free Space"

  - platform: sd_spi_card
    type: file_size
    name: "text.txt size"
    path: "/timelog.txt"

  - platform: sd_spi_card
    type: file_size
    name: "Timelog csv size"
    path: "/timelog.csv"

  - platform: uptime
    type: seconds
    id: uptime_1

  - platform: wifi_signal
    id: wifi_sig

binary_sensor:
  - platform: sd_spi_card
    name: "SD Card Status"
    on_press:
      - logger.log: "SD card is mounted"
      - output.turn_off: led
    on_release:
      - logger.log: "SD card is not mounted"
      - output.turn_on: led

output:
  - platform: gpio
    id: led
    pin: 
      inverted: True
      number: 2

interval:
  - interval: 10s
    then:   #append to text file 
      - lambda: |-
          auto t = id(sntp_time).now();
          if (t.is_valid()) {
            char buf[32];
            snprintf(buf, sizeof(buf), "%04d-%02d-%02d %02d:%02d:%02d",
                     t.year, t.month, t.day_of_month,
                     t.hour, t.minute, t.second);
            id(sd_1).append_file("/timelog.txt", buf);
          }
            
  - interval: 12s
    then:   #write to csv col 0 to 2, total 3 col
      - lambda: |-
          auto t = id(sntp_time).now();
          if (t.is_valid()) {
            char buf[32];
            snprintf(buf, sizeof(buf), "%04d-%02d-%02d %02d:%02d:%02d",
                     t.year, t.month, t.day_of_month,
                     t.hour, t.minute, t.second);
            id(sd_1).csv_append_row("/timelog.csv",
                                    {buf, to_string((int)id(uptime_1).state), to_string((int)id(wifi_sig).state)});
            }

  - interval: 15s
    then:  # Count row
      - lambda: |-
          int rows = id(sd_1).csv_row_count("/timelog.csv");
            ESP_LOGI("csv", "Total rows: %d", rows);
          

  - interval: 17s
    then:  # Read col 1 from row last 10
      - lambda: |-
          int total = id(sd_1).csv_row_count("/timelog.csv");
          int start = total > 10 ? total - 10 : 0;
          int end   = total - 1;

          int col_index = 1;  // we want column 1
          auto vals = id(sd_1).csv_read_column_range("/timelog.csv", col_index, start, end);

          int row = start;
           for (auto &v : vals) {
             ESP_LOGI("csv", "Row %d Col %d => %s", row, col_index, v.c_str());
             row++;
           }

  - interval: 20s
    then:  # Delete row from # - to #
      - lambda: |-
          id(sd_1).csv_delete_rows("/timelog.csv", -1, -1);
          

  - interval: 30s
    then:  # keep last 10000 row
      - lambda: |-
          id(sd_1).csv_keep_last_n("/timelog.csv", 10000);

  - interval: 1h
    then:
      - lambda: |-
          if (id(sd_1).delete_file("/timelog.csv")) {
            ESP_LOGI("sd_spi", "timelog.csv deleted successfully");
          } else {
            ESP_LOGE("sd_spi", "Failed to delete timelog.csv");
          }
